âœ… WHAT ARE UPSERTS (Deep Practical Meaning)
Upsert = UPDATE + INSERT combined.

MongoDB tries to update a document based on your filter.
If NO document matches â†’ MongoDB creates (inserts) a new document automatically.

So:

If match exists â†’ update it.
If match doesnâ€™t exist â†’ insert new doc.


This replaces the old pattern:

âŒ find â†’
âŒ if exists â†’ update
âŒ else â†’ insert

MongoDB does both in one atomic write operation.

ğŸ§  INTERNAL MENTAL MODEL (How MongoDB handles it)

When you do:

updateOne(
  { email: "abc@gmail.com" },
  { $set: { name: "Prathamesh" } },
  { upsert: true }
)


MongoDB does this internally:

Search in index for email: abc@gmail.com

If found â†’ update that document

If NOT found â†’

Create a new document

Merge your filter + update

Assign _id automatically

Commit the write atomically

This also means:

Your filter becomes part of the inserted document if no doc is found.
ğŸ”¥ PRACTICAL EXAMPLE (You MUST understand this)
Code:
db.users.updateOne(
  { email: "abc@gmail.com" },
  { $set: { name: "Prathamesh" } },
  { upsert: true }
);

CASE 1: Document exists
{ email: "abc@gmail.com", name: "Old Name" }


It becomes:

{ email: "abc@gmail.com", name: "Prathamesh" }

CASE 2: Document does NOT exist

Inserted document will be:

{
  _id: ObjectId(...),
  email: "abc@gmail.com",   // from the filter
  name: "Prathamesh"        // from $set
}

ğŸš€ DEEP PRACTICAL â€” INSERT BEHAVIOR
â—Important thing new developers MISS

When upsert happens:

ğŸ”¹ MongoDB inserts filter fields
ğŸ”¹ AND updates apply
ğŸ”¹ BUT update operators behave differently during insert

For example:

$setOnInsert


runs only during insert, not during update.

This is VERY powerful in real systems.

ğŸ§ª PRACTICAL EXERCISE (DO THIS)

Run the following code in Node.js:

const { MongoClient } = require("mongodb");

async function test() {
  const client = new MongoClient("mongodb://localhost:27017");
  await client.connect();

  const col = client.db("practice").collection("upsertTest");
  await col.deleteMany({});

  // 1. Upsert when no doc exists
  let r1 = await col.updateOne(
    { username: "prathamesh" },
    { $set: { score: 10 } },
    { upsert: true }
  );

  console.log("Upsert 1:", r1);

  // 2. Upsert when doc EXISTS
  let r2 = await col.updateOne(
    { username: "prathamesh" },
    { $inc: { score: 5 } },
    { upsert: true }
  );

  console.log("Upsert 2:", r2);

  console.log("Final Docs:", await col.find().toArray());
  client.close();
}

test();

Expected Output:

First call â†’ inserted

Second call â†’ updated

Final doc:

{ username: "prathamesh", score: 15 }


This is EXACT backend behavior.

ğŸ”¥ SUPER PRACTICAL REAL WORLD USE CASES
1. User login from Google OAuth

If user logs in first time â†’ create user
Else â†’ update their lastLogin timestamp

updateOne(
  { googleId },
  { $set: { lastLogin: new Date() }, $setOnInsert: { createdAt: new Date() } },
  { upsert: true }
)

2. File system metadata sync

When your app indexes files, some may be new, some existing.

Upserts avoid duplicate checks.

3. Caching system

If API result missing in DB â†’ insert
If exists â†’ update TTL

4. Analytics counters
updateOne(
  { userId },
  { $inc: { views: 1 } },
  { upsert: true }
)

âš ï¸ DEEP TRAP EVERY FRESHER MISSES

If your filter is incorrect, you will accidentally insert a WRONG document.

Example:

updateOne({ email: undefined }, ...)


â†’ inserts { email: null }
â†’ security bug
â†’ duplicates
â†’ data corruption

This is why backend engineers validate filters strictly.

ğŸ” ğŸ”¥ UPSERT RETURN RESULT (VERY IMPORTANT)

MongoDB returns:

upsertedId â†’ when insert happened

matchedCount â†’ if matched

modifiedCount â†’ if update happened

Example:

Insert case:
matchedCount: 0
modifiedCount: 0
upsertedId: ObjectId(...)

Update case:
matchedCount: 1
modifiedCount: 1
upsertedId: undefined


Backend devs use this to detect what happened.

//upserts with updateMany behavior
ğŸš¨ FIRST: THE CORE TRUTH (Most Developers Donâ€™t Know This)
ğŸ‘‰ updateMany with upsert: true NEVER inserts multiple documents.
ğŸ‘‰ It inserts ONLY ONE document. ALWAYS. EVER.

Even if your filter matches zero documents, MongoDB will create just one single document, not many.

This is the biggest misconception.

ğŸ”¥ DEEP INTERNAL WORKING â€” EXACT PIPELINE
When you run:
db.collection.updateMany(
  { age: 20 },
  { $set: { status: "active" } },
  { upsert: true }
);


MongoDB does:

Scan index for all docs where age = 20

If matches found â†’ update all of them

If NO matches found â†’
insert ONE document that looks like:

{
  age: 20,              // filter fields
  status: "active"      // update fields
}


Thatâ€™s it.
NOT 10 inserts.
NOT 3.
ONLY 1.

ğŸ§  WHY ONLY ONE INSERT?

BECAUSE:

upsert means â€œif NOTHING matches, create ONE document representing this condition.â€

It does not mean â€œcreate many possible variationsâ€.

MongoDB cannot guess how many documents you wanted to insert.
So it inserts just one.