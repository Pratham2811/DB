âœ… What Are Ordered Inserts in MongoDB?

MongoDBâ€™s insertMany() has an option called ordered.

Definition (In Simple Words):

Ordered inserts = MongoDB inserts documents one-by-one IN order.
If one document fails â†’ MongoDB STOPS immediately.

**Unordered inserts = MongoDB inserts documents in ANY order.

If one document fails â†’ MongoDB continues inserting remaining documents.**

ğŸ”¥ Deep Explanation (The Real Internals)

When you run:

db.collection.insertMany(docs, { ordered: true })


MongoDB will:

Take the array: [doc1, doc2, doc3, doc4...]

Insert doc1

If successful, insert doc2, then doc3, and so on

If ANY one fails (duplicate key, validation error, unique conflict):

MongoDB throws error

Stops processing the remaining documents

Returns partial result + error message

ğŸ¤¯ Why does MongoDB stop?

Because you explicitly told it:

â¡ï¸ â€œRespect this order strictly.â€
â¡ï¸ â€œIf something is wrong, donâ€™t continue. Abort.â€

MongoDB obeys.

ğŸ”„ Example of Ordered Inserts
db.users.insertMany(
  [
    { _id: 1, name: "A" },
    { _id: 2, name: "B" },
    { _id: 1, name: "C" }, // duplicate _id â†’ error
    { _id: 3, name: "D" }
  ],
  { ordered: true }
)

Result:

Inserts A â†’ OK

Inserts B â†’ OK

Inserts C â†’ fails (duplicate _id)

D is NEVER inserted

You get error: BulkWriteError

âš¡ Unordered Insert
db.users.insertMany(
  [
    { _id: 1, name: "A" },
    { _id: 2, name: "B" },
    { _id: 1, name: "C" }, 
    { _id: 3, name: "D" }
  ],
  { ordered: false }
)

Result:

A inserted

B inserted

C fails but ignored

D inserted anyway ğŸ‰

You still get partial error info

âœ”ï¸ When Should You Use Ordered Inserts?
Use ordered inserts when:

you need strict predictable order

your inserts depend on each other

first insert creates something needed by next insert

you want immediate failure

Use unordered inserts when:

performance matters (unordered is faster)

documents are independent

you want maximum successful inserts

you donâ€™t care about order

you want to avoid bulk failure because of one bad doc

ğŸš€ Performance Note
Unordered inserts are much faster

Because MongoDB parallelizes them internally.
Ordered inserts are slower since they run sequentially.

ğŸ§  In Node.js Example
await collection.insertMany(data, { ordered: true }); // default


OR

await collection.insertMany(data, { ordered: false });

ğŸ Brutally Honest Summary
Mode	Behavior	Good For	Bad For
ordered: true	Stop on error	dependent inserts	performance
ordered: false	Continue on error	bulk data, speed	strict ordering

Youâ€™re a backend developer â†’ unordered inserts are used 95% of the time in real-world systems unless ordering is required.

ğŸš€ DEEP PRACTICAL TRAINING â€“ Ordered / Unordered Inserts

(Exactly how backend engineers build intuition)

Weâ€™ll go in 4 rounds:

Mental Model â€“ How MongoDB behaves internally

Hands-on exercises you will actually do

Debugging tasks where you catch errors

Mini real-world backend scenario

1ï¸âƒ£ Mental Model â€“ Internal Working (Deep Practical View)
When you do:
insertMany(docs, { ordered: true })


MongoDB internally makes a bulk write pipeline:

Doc1 â†’ Doc2 â†’ Doc3 â†’ Doc4 â†’ ...


On each insert, MongoDB must wait for the previous insert to finish.

If Doc3 fails â†’ pipeline is aborted immediately.

Remaining docs are never even attempted.

When ordered = false:

MongoDB creates parallel execution batches:

Batch A â†’ Doc1, Doc3, Doc5
Batch B â†’ Doc2, Doc4, Doc6


Even if Doc3 fails in Batch A â†’ Batch B still runs.

Faster because it uses multiple internal worker threads.

ğŸ“Œ This is EXACT real behavior inside WiredTiger and MongoDBâ€™s WriteOps pipeline.

2ï¸âƒ£ Hands-On Exercises (YOU will do these)

Iâ€™ll give you code â†’ you run it â†’ observe results â†’ build intuition.

âœ… EXERCISE 1 â€” Ordered Inserts Failure Test

Paste this into your Node.js environment:

const { MongoClient } = require("mongodb");

async function run() {
  const client = new MongoClient("mongodb://localhost:27017");
  await client.connect();

  const col = client.db("practice").collection("orderedTest");
  await col.deleteMany({}); // clean

  try {
    await col.insertMany(
      [
        { _id: 1, name: "A" },
        { _id: 2, name: "B" },
        { _id: 1, name: "C" }, // DUPLICATE
        { _id: 3, name: "D" }
      ],
      { ordered: true }
    );
  } catch (err) {
    console.log("ERROR OCCURRED:");
    console.log(err.writeErrors);
  }

  const all = await col.find().toArray();
  console.log("FINAL DOCS:", all);

  client.close();
}

run();

Your expected output

Only A & B inserted

C errored

D never inserted

Final docs: [A, B]

Observe with your own eyes.

âœ… EXERCISE 2 â€” Unordered Inserts Parallel Test
await col.insertMany(
  [
    { _id: 1, name: "A" },
    { _id: 2, name: "B" },
    { _id: 1, name: "C" },
    { _id: 3, name: "D" }
  ],
  { ordered: false }
);

Expected Result:

A inserted

B inserted

C fails

D inserted

Final docs: [A, B, D]

This practice teaches you real behavior, not just theory.

3ï¸âƒ£ Debugging Tasks (These build real backend intuition)
â— Debug Task 1

You run an insert and MongoDB shows:

BulkWriteError: E11000 duplicate key error collection...


Question:
How do you know whether any other docs were inserted or not?

Your Answer Should Be:
Check:

err.writeErrors
err.result.result.nInserted


This tells you if ordered stopped early or unordered continued.

â— Debug Task 2

Imagine user sends 500 docs for bulk upload.
One doc has bad email format â†’ throw validation error.

What happens in ordered vs unordered?

Answer:

Mode	Outcome
ordered:true	upload stops at incorrect doc, rest rejected
ordered:false	499 valid docs inserted, 1 invalid failed

This is critical for designing APIs.

4ï¸âƒ£ REAL-WORLD BACKEND SCENARIO (Most Important Practical)

Letâ€™s simulate your real project:

Scenario

User uploads 1000 files metadata into MongoDB.
One record has duplicate file id.

If you use ordered:true:

Your entire upload API fails

User loses all progress

Terrible UX

If you use ordered:false:

999 entries succeed

1 duplicate is reported

You return:

{
  "inserted": 999,
  "failed": 1,
  "errors": ["duplicate _id"]
}


This is REAL backend architecture decision-making.